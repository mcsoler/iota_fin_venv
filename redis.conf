# Ejemplo de archivo de configuración de Redis.
#
# Tenga en cuenta que para leer el archivo de configuración, Redis debe ser
# comenzó con la ruta del archivo como primer argumento:
#
# ./redis-server /ruta/a/redis.conf

# Nota sobre unidades: cuando se necesita el tamaño de la memoria, es posible especificar
# en la forma habitual de 1k 5GB 4M y así sucesivamente:
#
# 1k => 1000 bytes
# 1kb => 1024 bytes
# 1m => 1000000 bytes
# 1mb => 1024*1024 bytes
# 1g => 1000000000 bytes
# 1gb => 1024*1024*1024 bytes
#
# Las unidades # son insensibles a los casos, por lo que 1GB 1Gb 1gB son todas iguales.

################################## INCLUYE ###################################

# Incluya uno o más archivos de configuración aquí.  Esto es útil si usted
# tiene una plantilla estándar que va a todos los servidores Redis, pero también necesita
# para personalizar algunas configuraciones por servidor.  Incluir archivos puede incluir
# otros archivos, así que use esto sabiamente.
#
# La opción de aviso "incluir" no se reescribirá con el comando "CONFIG REWRITE"
# de admin o Redis Sentinel. Como Redis siempre usa el último procesado
# línea como valor de una directiva de configuración, será mejor que incluya
# al comienzo de este archivo para evitar sobrescribir el cambio de configuración en tiempo de ejecución.
#
# Si, en cambio, está interesado en usar incluye para anular la configuración
# opciones, es mejor usar incluir como última línea.
#
# incluye /path/to/local.conf
# incluye /path/to/other.conf

################################## MÓDULOS #####################################

# Cargue módulos al inicio. Si el servidor no puede cargar módulos
# abortará. Es posible utilizar múltiples directivas de módulos de carga.
#
# loadmodule / path / to / my_module.so
# loadmodule / path / to / other_module.so

##################################  #####################################

# De forma predeterminada, si no se especifica una directiva de configuración de "enlace", Redis escucha
# para conexiones desde todas las interfaces de red disponibles en el servidor.
# Es posible escuchar solo una o múltiples interfaces seleccionadas usando
# la directiva de configuración "bind", seguida de una o más direcciones IP.
#
# Ejemplos:
#
# enlazar 192.168.1.100 10.0.0.1
# enlazar 127.0.0.1 ::1
#
# ~~~ ADVERTENCIA ~~~ Si la computadora que ejecuta Redis está directamente expuesta al
# internet, la vinculación a todas las interfaces es peligrosa y expondrá el
# instancia para todos en Internet. Así que por defecto descomentamos el
# siguiendo la directiva de enlace, eso obligará a Redis a escuchar solo
# la dirección de interfaz de bucle invertido IPv4 (esto significa que Redis podrá
# acepte conexiones solo de clientes que se ejecutan en la misma computadora
# está corriendo).
#
# SI ESTÁ SEGURO DE QUE DESEA QUE SU INSTANCIA ESCUCHE TODAS LAS INTERFACES
# SOLO COMENTA LA SIGUIENTE LÍNEA.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
enlace 127.0.0.1

# El modo protegido es una capa de protección de seguridad, para evitar eso
# Se accede y explota a las instancias de Redis que se dejan abiertas en Internet.
#
# Cuando el modo protegido está encendido y si:
#
# 1) El servidor no está enlazando explícitamente a un conjunto de direcciones usando el
#    "Directiva "bind.
# 2) No se configura ninguna contraseña.
#
# El servidor solo acepta conexiones de clientes que se conectan desde el
# Direcciones de bucle invertido IPv4 e IPv6 127.0.0.1 y ::1, y desde el dominio Unix
# enchufes.
#
# Por defecto el modo protegido está habilitado. Debe desactivarlo solo si
# está seguro de que desea que los clientes de otros hosts se conecten a Redis
# incluso si no se configura ninguna autenticación, ni un conjunto específico de interfaces
# se enumeran explícitamente utilizando la directiva "agregar.
modo protegido sí

# Acepte conexiones en el puerto especificado, el valor predeterminado es 6379 ( IANA # 815344 ).
# Si se especifica el puerto 0, Redis no escuchará en un socket TCP.
puerto 6379

# TCP escucha ( ) backlog.
#
# En entornos de altas solicitudes por segundo, necesita una alta cartera de pedidos en orden
# para evitar problemas lentos de conexiones con los clientes. Tenga en cuenta que el kernel de Linux
# lo truncará en silencio al valor de / proc / sys / net / core / somaxconn so
# asegúrese de aumentar tanto el valor de somaxconn como tcp_max_syn_backlog
# para obtener el efecto deseado.
tcp-backlog 511

# Unix socket.
#
# Especifique la ruta para el socket Unix que se utilizará para escuchar
# conexiones entrantes. No hay defecto, por lo que Redis no escuchará
# en un socket unix cuando no se especifica.
#
# unixsocket /tmp/redis.sock
# unixsocketperm 700

# Cierre la conexión después de que un cliente esté inactivo durante N segundos (0 para deshabilitar)
tiempo de espera 0

# TCP keepalive.
#
# Si no es cero, use SO_KEEPALIVE para enviar ACK TCP a clientes en ausencia
# de comunicación. Esto es útil por dos razones:
#
# 1) Detecta compañeros muertos.
# 2) Tome la conexión viva desde el punto de vista de la red
#    equipo en el medio.
#
# En Linux, el valor especificado (en segundos) es el período utilizado para enviar ACK.
# Tenga en cuenta que para cerrar la conexión se necesita el doble del tiempo.
# En otros núcleos, el período depende de la configuración del núcleo.
#
# Un valor razonable para esta opción es de 300 segundos, que es el nuevo
# Redis por defecto a partir de Redis 3.2.1.
300 TcP-keepalive

################################# GENERAL #####################################

# Por defecto Redis no se ejecuta como un demonio. Usa 'sí' si lo necesitas.
# Tenga en cuenta que Redis escribirá un archivo pid en /var/run/redis.pid cuando esté daemonizado.
daemonizar no

# Si ejecuta Redis desde upstart o systemd, Redis puede interactuar con su
# árbol de supervisión. Opciones:
#   supervisado no - ninguna interacción de supervisión
#   upstart supervisado - señal upstart poniendo Redis en modo SIGSTOP
#   supervised systemd - signal systemd escribiendo READY=1 a $NOTIFY_SOCKET
#   auto supervisado: detecte el método upstart o systemd basado en
#                        Variables de entorno UPSTART_JOB o NOTIFY_SOCKET
# Nota: estos métodos de supervisión solo indican que "el proceso está listo."
#       No permiten pings de vida continua a su supervisor.
supervisado no

# Si se especifica un archivo pid, Redis lo escribe donde se especifica al inicio
# y lo elimina a la salida.
#
# Cuando el servidor se ejecuta no daemonizado, no se crea ningún archivo pid si no lo es
# especificado en la configuración. Cuando el servidor está daemonizado, el archivo pid
# se usa incluso si no se especifica, por defecto en "/var/run/redis.pid".
#
# Crear un archivo pid es el mejor esfuerzo: si Redis no puede crearlo
# no pasa nada malo, el servidor se iniciará y se ejecutará normalmente.
pidfile /var/run/redis_6379.pid

# Especifique el nivel de verbosidad del servidor.
# Este puede ser uno de:
# depuración (mucha información, útil para el desarrollo/pruebas)
# verbose (mucha información rara vez útil, pero no un desastre como el nivel de depuración)
# aviso (moderadamente detallado, lo que quieres en producción probablemente)
# advertencia (solo se registran mensajes muy importantes /críticos)
aviso de nivel de registro

# Especifique el nombre del archivo de registro. También la cadena vacía se puede utilizar para forzar
# Redis para iniciar sesión en la salida estándar. Tenga en cuenta que si usa estándar
# salida para el registro pero daemonize, los registros se enviarán a /dev/null
archivo de registro ""

# Para habilitar el registro en el registrador del sistema, simplemente configure 'syslog habilitado' en sí,
# y opcionalmente actualizar los otros parámetros de syslog para satisfacer sus necesidades.
# syslog habilitado no

# Especifique la identidad de syslog.
# syslog-ident redis

# Especifique la instalación de syslog. Debe ser USUARIO o entre LOCAL0-LOCAL7.
# syslog-instalación local0

# Establezca el número de bases de datos. La base de datos predeterminada es DB 0, puede seleccionar
# uno diferente por conexión usando SELECT <dbid> donde
# dbid es un número entre 0 y 'bases de datos'-1
bases de datos 16

# De forma predeterminada, Redis muestra un logotipo de arte ASCII solo cuando se inicia sesión en el
# salida estándar y si la salida estándar es un TTY. Básicamente esto significa
# que normalmente un logotipo se muestra solo en sesiones interactivas.
#
# Sin embargo, es posible forzar el comportamiento pre-4.0 y mostrar siempre un
# logotipo de arte ASCII en los registros de inicio configurando la siguiente opción en sí.
siempre-show-logo sí

################################ SNAPSHOTTING  ################################
#
# Guarde el DB en el disco:
#
#   guardar <segundos> <changes>
#
#   Guardará el DB si tanto el número dado de segundos como el dado
#   se produjo el número de operaciones de escritura contra el DB.
#
#   En el ejemplo a continuación, el comportamiento será guardar:
#   después de 900 seg (15 min) si se cambia al menos 1 tecla
#   después de 300 seg (5 min) si se cambian al menos 10 teclas
#   después de 60 segundos si se cambian al menos 10000 teclas
#
#   Nota: puede deshabilitar el ahorro por completo comentando todas las líneas de "guardar.
#
#   También es posible eliminar toda la guardada configurada previamente
#   apunta agregando una directiva de guardado con un solo argumento de cadena vacía
#   como en el siguiente ejemplo:
#
#   guardar ""

guardar 900 1
guardar 300 10
guardar 60 10000

# De forma predeterminada, Redis dejará de aceptar escrituras si las instantáneas de RDB están habilitadas
# (al menos un punto de guardado) y el último guardado de fondo falló.
# Esto hará que el usuario sepa (de una manera difícil) que los datos no persisten
# en el disco correctamente, de lo contrario es probable que nadie se dé cuenta y algunos
# el desastre sucederá.
#
# Si el proceso de ahorro de fondo comenzará a funcionar nuevamente, Redis lo hará
# permitir automáticamente escribir de nuevo.
#
# Sin embargo, si ha configurado su monitoreo adecuado del servidor Redis
# y persistencia, es posible que desee deshabilitar esta función para que Redis lo haga
# continúe funcionando como de costumbre, incluso si hay problemas con el disco,
# permisos, y así sucesivamente.
stop-writes-on-bgsave-error sí

# Comprimir objetos de cadena usando LZF cuando volcar bases de datos .rdb?
# Por defecto, está configurado en 'sí' ya que casi siempre es una victoria.
# Si desea guardar alguna CPU en el niño salvador, configúrela en 'no' pero
# el conjunto de datos probablemente será más grande si tiene valores o claves compresibles.
rdbcompression sí

# Desde la versión 5 de RDB, se coloca una suma de verificación CRC64 al final del archivo.
# Esto hace que el formato sea más resistente a la corrupción, pero hay una actuación
# hit to pay ( alrededor del 10% ) al guardar y cargar archivos RDB, para que pueda deshabilitarlo
# para actuaciones máximas.
#
# Los archivos RDB creados con suma de comprobación deshabilitada tienen una suma de comprobación de cero que
# dígale al código de carga que omita la verificación.
rdbchecksum sí

# El nombre del archivo donde volcar el DB
dbfilename dump.rdb

# El directorio de trabajo.
#
# El DB se escribirá dentro de este directorio, con el nombre de archivo especificado
# arriba usando la directiva de configuración 'dbfilename.
#
# El archivo Append Only también se creará dentro de este directorio.
#
# Tenga en cuenta que debe especificar un directorio aquí, no un nombre de archivo.
dir ./

################################# REPLICACIÓN #################################

# Replicación de Master-Replica. Utilice replicaof para hacer de una instancia de Redis una copia de
# otro servidor Redis. Algunas cosas para entender ASAP sobre la replicación de Redis.
#
#   +--------------------+ +-------------
#   | Master | ---> | Réplica |
#   | (recibe escrituras) | | (copia exacta) |
#   +--------------------+ +-------------
#
# 1) La replicación de Redis es asíncrona, pero puede configurar un maestro para
#    deja de aceptar escrituras si parece que no están conectadas con al menos
#    un número dado de réplicas.
# 2) Las réplicas de Redis pueden realizar una resincronización parcial con el
#    maestro si el enlace de replicación se pierde por una cantidad relativamente pequeña de
#    tiempo. Es posible que desee configurar el tamaño del backlog de replicación (consulte el siguiente
#    secciones de este archivo) con un valor razonable dependiendo de sus necesidades.
# 3) La replicación es automática y no necesita intervención del usuario. Después de un
#    las réplicas de partición de red intentan automáticamente volver a conectarse a los maestros
#    y resincronizar con ellos.
#
# réplica de <masterip> <masterport>

# Si el maestro está protegido con contraseña ( usando la configuración "requirepass"
# directiva a continuación ) es posible indicar a la réplica que se autentique antes
# iniciar el proceso de sincronización de replicación, de lo contrario el maestro lo hará
# rechazar la solicitud de réplica.
#
# masterauth < master-password >

# Cuando una réplica pierde su conexión con el maestro, o cuando la replicación
# todavía está en progreso, la réplica puede actuar de dos maneras diferentes:
#
# 1 ) si réplica-serve-stale-data se establece en 'sí' ( el valor predeterminado ) la réplica
#    aún responde a las solicitudes del cliente, posiblemente con datos desactualizados, o el
#    el conjunto de datos puede estar vacío si esta es la primera sincronización.
#
# 2 ) si réplica-serve-stale-data está configurada en 'no', la réplica responderá con
#    un error "SYNC con master en progreso" a todo el tipo de comandos
#    pero a INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG, etc,
#    SUSCRIBIRSE, DARSE DE BAJA, PSUBSCRIBIRSE, PUNSUSCRIBIRSE, PUBLICAR, PUBSUB, ETC,
#    COMANDO, POST, HOST: y LATENCIA.
#
replica-serve-stale-data sí

# Puede configurar una instancia de réplica para aceptar escrituras o no. Escribiendo en contra
# una instancia de réplica puede ser útil para almacenar algunos datos efímeros (porque los datos
# escrito en una réplica se eliminará fácilmente después de resincronizar con el maestro) pero
# también puede causar problemas si los clientes le están escribiendo debido a un
# configuración errónea.
#
# Dado que Redis 2.6 por defecto las réplicas son de solo lectura.
#
# Nota: las réplicas de solo lectura no están diseñadas para exponerse a clientes no confiables
# en internet. Es solo una capa de protección contra el mal uso de la instancia.
# Todavía una réplica de solo lectura exporta por defecto todos los comandos administrativos
# como CONFIG, DEBUG, etc. Hasta cierto punto, puede mejorar
# seguridad de réplicas de solo lectura usando 'rename-command' para sombrear todo el
# órdenes administrativas /peligrosas.
sí solo lectura de réplica

# Estrategia de SYNC de replicación: disco o socket.
#
# --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# ADVERTENCIA: LA REPLICACIÓN SIN DISCO ES EXPERIMENTAL ACTUALMENTE
# --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#
# Nuevas réplicas y réplicas de reconexión que no pueden continuar la replicación
# proceso sólo recibir diferencias, necesidad de hacer lo que se llama un "lleno
# sincronización". Un archivo RDB se transmite del maestro a las réplicas.
# La transmisión puede ocurrir de dos maneras diferentes:
#
# 1) Respaldado por disco: El maestro Redis crea un nuevo proceso que escribe el RDB
#                 archivo en disco. Más tarde, el archivo es transferido por el padre
#                 proceso a las réplicas de forma incremental.
# 2) Diskless: El maestro de Redis crea un nuevo proceso que escribe directamente el
#              Archivo RDB para replicar sockets, sin tocar el disco en absoluto.
#
# Con replicación respaldada por disco, mientras se genera el archivo RDB, más réplicas
# se puede poner en cola y servir con el archivo RDB tan pronto como el niño actual produzca
# el archivo RDB termina su trabajo. Con replicación sin disco en su lugar una vez
# comienza la transferencia, nuevas réplicas que llegan se pondrán en cola y una nueva transferencia
# comenzará cuando termine el actual.
#
# Cuando se utiliza la replicación sin disco, el maestro espera una cantidad configurable de
# tiempo (en segundos) antes de iniciar la transferencia con la esperanza de que múltiples réplicas
# llegará y la transferencia se puede paralelizar.
#
# Con discos lentos y redes rápidas de ancho de banda grande (, replicación sin disco
# funciona mejor.
rep-diskless-sync no

# Cuando la replicación sin disco está habilitada, es posible configurar el retraso
# el servidor espera para engendrar al niño que transfiere el RDB a través del socket
# a las réplicas.
#
# Esto es importante ya que una vez que comienza la transferencia, no es posible servir
# nuevas réplicas que lleguen, que se colocarán en cola para la próxima transferencia RDB, por lo que el servidor
# espera un retraso para permitir que lleguen más réplicas.
#
# El retraso se especifica en segundos y, por defecto, es de 5 segundos. Deshabilitar
# simplemente lo configuró en 0 segundos y la transferencia comenzará lo antes posible.
rep-diskless-sync-delay 5

# Las réplicas envían PING al servidor en un intervalo predefinido. Es posible cambiar
# este intervalo con la opción repl_ping_replica_period. El valor predeterminado es 10
# segundos.
#
# rep-ping-replica-período 10

# La siguiente opción establece el tiempo de espera de replicación para:
#
# 1) E/S de transferencia masiva durante SYNC, desde el punto de vista de la réplica.
# 2) Tiempo de espera maestro desde el punto de vista de las réplicas (datos, pings).
# 3) Tiempo de espera de réplica desde el punto de vista de los maestros (REPLCONF ACK pings).
#
# Es importante asegurarse de que este valor es mayor que el valor
# especificado para el período de repetición-ping-réplica, de lo contrario se detectará un tiempo de espera
# cada vez que hay poco tráfico entre el maestro y la réplica.
#
# tiempo de espera 60

# Desactivar TCP_NODELAY en el socket de réplica después de SYNC?
#
# Si selecciona "sí", Redis usará un número menor de paquetes TCP y
# menos ancho de banda para enviar datos a réplicas. Pero esto puede agregar un retraso para
# los datos que aparecen en el lado de la réplica, hasta 40 milisegundos con
# Kernels de Linux usando una configuración predeterminada.
#
# Si selecciona "no", el retraso para que los datos aparezcan en el lado de la réplica
# se reducirá, pero se utilizará más ancho de banda para la replicación.
#
# Por defecto optimizamos para baja latencia, pero en condiciones de tráfico muy altas
# o cuando el maestro y las réplicas están a muchos saltos de distancia, convertir esto en "sí" puede
# sé una buena idea.
repl-disable-tcp-nodelay no

# Establezca el tamaño del backlog de replicación. El retraso es un búfer que se acumula
# replicar datos cuando las réplicas se desconectan durante algún tiempo, de modo que cuando una réplica
# quiere volver a conectarse, a menudo no se necesita una resincronización completa, sino una parcial
# resync es suficiente, simplemente pasando la parte de datos que la réplica perdió mientras
# desconectado.
#
# Cuanto mayor sea el retraso de replicación, mayor será el tiempo que la réplica puede ser
# desconectado y posteriormente poder realizar una resincronización parcial.
#
# El retraso solo se asigna una vez que hay al menos una réplica conectada.
#
# repl-backlog-tamaño 1mb

# Después de que un maestro ya no ha conectado réplicas durante algún tiempo, el retraso
# será liberado. La siguiente opción configura la cantidad de segundos que
# necesita transcurrir, a partir del momento en que la última réplica se desconectó, para
# el búfer de retraso a liberar.
#
# Tenga en cuenta que las réplicas nunca liberan el retraso para el tiempo de espera, ya que pueden ser
# promovido a maestros más tarde, y debería ser capaz de "parcialmente correctamente
# resincronizar" con las réplicas: por lo tanto, siempre deben acumular retraso.
#
# Un valor de 0 significa nunca liberar el retraso.
#
# repl-backlog-ttl 3600

# La prioridad de réplica es un número entero publicado por Redis en la salida INFO.
# Es utilizado por Redis Sentinel con el fin de seleccionar una réplica para promover en un
# maestro si el maestro ya no funciona correctamente.
#
# Una réplica con un número de baja prioridad se considera mejor para la promoción, por lo que
# por ejemplo si hay tres réplicas con prioridad 10, 100, 25 Sentinel lo hará
# elige el que tenga prioridad 10, ese es el más bajo.
#
# Sin embargo, una prioridad especial de 0 marca la réplica como no capaz de realizar el
# rol de maestro, por lo que una réplica con prioridad de 0 nunca será seleccionada por
# Redis Sentinel para promoción.
#
# Por defecto la prioridad es 100.
réplica-prioridad 100

# Es posible que un maestro deje de aceptar escrituras si hay menos de
# N réplicas conectadas, teniendo un retraso menor o igual que M segundos.
#
# Las N réplicas deben estar en estado "en línea.
#
# El retraso en segundos, que debe ser <= el valor especificado, se calcula a partir de
# el último ping recibido de la réplica, que generalmente se envía cada segundo.
#
# Esta opción no GARANTIZA que N réplicas aceptarán la escritura, pero
# limitará la ventana de exposición para escrituras perdidas en caso de que no haya suficientes réplicas
# están disponibles, para el número especificado de segundos.
#
# Por ejemplo, para requerir al menos 3 réplicas con un retraso <= 10 segundos de uso:
#
# min-réplicas a escribir 3
# min-réplicas-max-lag 10
#
# Establecer uno u otro en 0 deshabilita la función.
#
# Por defecto min-replicas-to-write se establece en 0 (función deshabilitada) y
# min-replicas-max-lag se establece en 10.

# Un maestro de Redis puede enumerar la dirección y el puerto del adjunto
# réplicas de diferentes maneras. Por ejemplo, la sección "replicación de INFO"
# ofrece esta información, que se utiliza, entre otras herramientas, por
# Redis Sentinel para descubrir instancias de réplica.
# Otro lugar donde esta información está disponible es en la salida de la
# "ROLE" comando de un maestro.
#
# Se obtiene la IP y la dirección listadas normalmente reportadas por una réplica
# de la siguiente manera:
#
#   IP: La dirección se detecta automáticamente al verificar la dirección del par
#   del socket utilizado por la réplica para conectar con el maestro.
#
#   Puerto: El puerto es comunicado por la réplica durante la replicación
#   apretón de manos, y es normalmente el puerto al que la réplica está usando
#   escucha las conexiones.
#
# Sin embargo, cuando el reenvío de puertos o la Traducción de Direcciones de Red (NAT) es
# usado, la réplica puede ser realmente accesible a través de diferentes IP y puerto
# pares. Las siguientes dos opciones pueden ser utilizadas por una réplica para
# informar a su maestro un conjunto específico de IP y puerto, de modo que ambos INFO
# y ROLE informarán esos valores.
#
# No hay necesidad de usar ambas opciones si necesita anular solo
# el puerto o la dirección IP.
#
# réplica-announce-ip 5.5.5.5
# réplica-anuncio-puerto 1234

################################## SEGURIDAD ###################################

# Requiere que los clientes emitan AUTH <PASSWORD> antes de procesar cualquier otro
# comandos.  Esto podría ser útil en entornos en los que no confía
# otros con acceso al host que ejecuta redis-server.
#
# Esto debería mantenerse comentado por la compatibilidad con versiones anteriores y porque la mayoría
# las personas no necesitan auth (por ejemplo, ejecutan sus propios servidores).
#
# Advertencia: dado que Redis es bastante rápido, un usuario externo puede intentar
# 150k contraseñas por segundo contra una buena caja. Esto significa que deberías
# use una contraseña muy segura, de lo contrario será muy fácil de romper.
#
# requiere pasar foobared

# Cambio de nombre de comando.
#
# Es posible cambiar el nombre de comandos peligrosos en un compartido
# ambiente. Por ejemplo, el comando CONFIG puede renombrarse en algo
# difícil de adivinar para que todavía esté disponible para herramientas de uso interno
# pero no disponible para clientes generales.
#
# Ejemplo:
#
# cambiar el nombre-comando CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
#
# También es posible matar completamente un comando renombrándolo en
# una cadena vacía:
#
# cambiar el nombre-comando CONFIG ""
#
# Tenga en cuenta que cambiar el nombre de los comandos que han iniciado sesión en el
# El archivo #AOF o transmitido a réplicas puede causar problemas.

################################### CLIENTES ####################################

# Establezca el número máximo de clientes conectados al mismo tiempo. Por defecto
# este límite se establece en 10000 clientes, sin embargo, si el servidor Redis no lo es
# capaz de configurar el límite del archivo de proceso para permitir el límite especificado
# el número máximo de clientes permitidos se establece en el límite de archivo actual
# menos 32 (ya que Redis reserva algunos descriptores de archivos para usos internos).
#
# Una vez alcanzado el límite, Redis cerrará todas las nuevas conexiones que envían
# un error 'número máximo de clientes alcanzados'.
#
# maxclients 10000

############################## GESTIÓN DE MEMORIA ################################

# Establezca un límite de uso de memoria para la cantidad especificada de bytes.
# Cuando se alcanza el límite de memoria, Redis intentará eliminar las teclas
# según la política de desalojo seleccionada (ver política de maxmemory).
#
# Si Redis no puede eliminar las claves de acuerdo con la política, o si la política es
# establecido en 'noeviction', Redis comenzará a responder con errores a los comandos
# eso usaría más memoria, como SET, LPUSH, etc., y continuará
# para responder a comandos de solo lectura como GET.
#
# Esta opción suele ser útil cuando se utiliza Redis como caché LRU o LFU, o para
# establezca un límite de memoria dura para una instancia (usando la política de 'noeviction').
#
# ADVERTENCIA: Si tiene réplicas adjuntas a una instancia con maxmemory activado,
# se resta el tamaño de los tampones de salida necesarios para alimentar las réplicas
# desde el recuento de memoria utilizado, de modo que los problemas de red /resincronizaciones lo harán
# no activar un bucle donde las claves son desalojadas, y a su vez la salida
# el búfer de réplicas está lleno con DEL de claves desalojadas que activan la eliminación
# de más claves, y así sucesivamente hasta que la base de datos esté completamente vacía.
#
# En resumen... Si tiene réplicas adjuntas, se sugiere que establezca una más baja
# límite para maxmemory para que haya algo de RAM gratis en el sistema para la réplica
# buffers de salida (pero esto no es necesario si la política es 'noeviction').
#
# maxmemory <bytes>

# MAXMEMORY POLICY: cómo Redis seleccionará qué eliminar cuando maxmemory
# se alcanza. Puede seleccionar entre cinco comportamientos:
#
# volatile-lru -> Evict usando LRU aproximado entre las teclas con un conjunto de caducidad.
# allkeys-lru -> Evict cualquier clave usando LRU aproximado.
# volatile-lfu -> Evict usando LFU aproximado entre las teclas con un conjunto de caducidad.
# allkeys-lfu -> Evict cualquier clave usando LFU aproximado.
# volatile-random -> Eliminar una clave aleatoria entre las que tienen un conjunto de caducidad.
# allkeys-random -> Eliminar una clave aleatoria, cualquier clave.
# volatile-ttl -> Eliminar la clave con el tiempo de caducidad más cercano (menor TTL)
# noeviction -> No desalojes nada, solo devuelve un error en las operaciones de escritura.
#
# LRU significa Menos Utilizado Recientemente
# LFU significa Menos Frecuentemente Utilizado
#
# Tanto LRU, LFU como volatile-ttl se implementan usando aproximado
# algoritmos aleatorios.
#
# Nota: con cualquiera de las políticas anteriores, Redis devolverá un error al escribir
#       operaciones, cuando no hay claves adecuadas para el desalojo.
#
#       En la fecha de escritura estos comandos son: set setnx setex append
#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
#       getset mset msetnx exec ordenar
#
# El valor predeterminado es:
#
# maxmemory-policy noeviction

# LRU, LFU y algoritmos TTL mínimos no son algoritmos precisos sino aproximados
# algoritmos (para guardar memoria), para que pueda sintonizarlo para la velocidad o
# precisión. Por defecto, Redis comprobará cinco teclas y elegirá la que era
# usado menos recientemente, puede cambiar el tamaño de la muestra usando lo siguiente
# directiva de configuración.
#
# El valor predeterminado de 5 produce resultados lo suficientemente buenos. 10 Se aproxima muy de cerca
# verdadero LRU pero cuesta más CPU. 3 es más rápido pero no muy preciso.
#
# maxmemory-muestras 5

# A partir de Redis 5, de forma predeterminada, una réplica ignorará su configuración de maxmemory
# (a menos que se promueva a master después de una conmutación por error o manualmente). Significa
# que el desalojo de llaves será manejado por el maestro, enviando el
# Comandos DEL a la réplica como desalojo de claves en el lado maestro.
#
# Este comportamiento asegura que los maestros y las réplicas se mantengan consistentes, y generalmente lo son
# lo que quieres, sin embargo, si tu réplica es escribible, o si quieres que la réplica tenga
# una configuración de memoria diferente, y está seguro de que todas las escrituras se realizaron en el
# la réplica es idempotente, entonces puede cambiar este valor predeterminado (pero asegúrese de entender
# lo que estás haciendo).
#
# Tenga en cuenta que dado que la réplica por defecto no desaloja, puede terminar usando más
# memoria que el conjunto a través de maxmemory (hay ciertos búferes que pueden
# sea más grande en la réplica, o las estructuras de datos a veces pueden tomar más memoria y así
# adelante). Así que asegúrese de monitorear sus réplicas y asegúrese de que tengan suficiente
# memoria para nunca golpear una condición real fuera de memoria antes de que el maestro golpea
# la configuración de maxmemory configurada.
#
# replica-ignore-maxmemory sí

#############################  ####################################

# Redis tiene dos primitivas para eliminar claves. Uno se llama DEL y es un bloqueo
# eliminación del objeto. Significa que el servidor deja de procesar nuevos comandos
# con el fin de recuperar toda la memoria asociada con un objeto en un síncrono
# camino. Si la clave eliminada está asociada con un objeto pequeño, el tiempo necesario
# para ejecutar el comando DEL es muy pequeño y comparable a la mayoría de los otros
# Comandos #O(1) u O(log_N) en Redis. Sin embargo, si la clave está asociada con un
# valor agregado que contiene millones de elementos, el servidor puede bloquear para
# mucho tiempo (incluso segundos) para completar la operación.
#
# Por las razones anteriores, Redis también ofrece primitivas de eliminación sin bloqueo
# como UNLINK (no bloqueo DEL) y la opción ASYNC de FLUSHALL y
# Comandos FLUSHDB, para recuperar la memoria en segundo plano. Esos comandos
# se ejecutan en tiempo constante. Otro hilo liberará incrementalmente el
# objeto en el fondo lo más rápido posible.
#
# DEL, UNLINK y ASYNC opción de FLUSHALL y FLUSHDB están controlados por el usuario.
# Depende del diseño de la aplicación entender cuándo es buena
# idea de usar uno u otro. Sin embargo, el servidor Redis a veces tiene que hacerlo
# eliminar claves o eliminar toda la base de datos como un efecto secundario de otras operaciones.
# Específicamente Redis elimina objetos independientemente de una llamada de usuario en el
# siguientes escenarios:
#
# 1) Sobre el desalojo, debido a las configuraciones de política de maxmemory y maxmemory,
#    para dejar espacio para nuevos datos, sin repasar lo especificado
#    límite de memoria.
# 2) Debido a caducar: cuando una clave con un tiempo asociado para vivir (ver el
#    El comando # EXPIRE) debe eliminarse de la memoria.
# 3) Debido a un efecto secundario de un comando que almacena datos en una clave que puede
#    ya existe. Por ejemplo, el comando RENAME puede eliminar la clave antigua
#    contenido cuando se reemplaza por otro. Del mismo modo SUNIONSTORE
#    o SORT con la opción STORE puede eliminar las claves existentes. El comando SET
#    elimina cualquier contenido antiguo de la clave especificada para reemplazar
#    con la cadena especificada.
# 4) Durante la replicación, cuando una réplica realiza una resincronización completa con
#    su maestro, el contenido de toda la base de datos se elimina para
#    cargue el archivo RDB que acaba de transferir.
#
# En todos los casos anteriores, el valor predeterminado es eliminar objetos de forma bloqueante,
# como si se llamara DEL. Sin embargo, puede configurar cada caso específicamente
# para liberar la memoria de una manera no bloqueante como si fuera UNLINK
# fue llamado, usando las siguientes directivas de configuración:

lazyfree-lazy-desalojo no
lazyfree-lazy-expire no
lazyfree-lazy-server-del no
no replica-lazy-flush

############################## ADJUNTAR SOLO MODO ###############################

# De forma predeterminada, Redis descarga asíncrona el conjunto de datos en el disco. Este modo es
# suficientemente bueno en muchas aplicaciones, pero un problema con el proceso de Redis o
# un corte de energía puede resultar en unos minutos de escrituras perdidas (dependiendo de
# los puntos de guardado configurados).
#
# The Append Only File es un modo de persistencia alternativo que proporciona
# durabilidad mucho mejor. Por ejemplo, utilizando la política de datos predeterminada fsync
# (ver más adelante en el archivo de configuración) Redis puede perder sólo un segundo de escrituras en un
# evento dramático como un corte de energía del servidor, o una sola escritura si algo
# mal con el proceso de Redis en sí ocurre, pero el sistema operativo es
# sigue funcionando correctamente.
#
# La persistencia #AOF y RDB se puede habilitar al mismo tiempo sin problemas.
# Si el AOF está habilitado en el inicio, Redis cargará el AOF, ese es el archivo
# con las mejores garantías de durabilidad.
#
# Compruebe http://redis.io/topics/persistence para obtener más información.

apéndice no

# El nombre del archivo append only (predeterminado: "appendonly.aof")

appendfilename "appendonly.aof"

# La llamada fsync() le dice al Sistema Operativo que realmente escriba datos en el disco
# en lugar de esperar más datos en el búfer de salida. Algunos OS realmente se enjuagarán
# datos en el disco, algún otro sistema operativo solo intentará hacerlo ASAP.
#
# Redis admite tres modos diferentes:
#
# no: no fsync, solo deje que el sistema operativo elimine los datos cuando lo desee. Más rápido.
# siempre: fsync después de cada escritura en el registro de solo apéndice. Lento, Más seguro.
# everysec: fsync solo una vez por segundo. Compromiso.
#
# El valor predeterminado es "everysec", ya que generalmente es el compromiso correcto entre
# velocidad y seguridad de datos. Depende de usted entender si puede relajar esto para
# "no" que permitirá que el sistema operativo elimine el búfer de salida cuando
# quiere, para mejores actuaciones (pero si puedes vivir con la idea de
# algunas pérdidas de datos consideran el modo de persistencia predeterminado que es instantánea),
# o por el contrario, use "siempre" que sea muy lento pero un poco más seguro que
# everysec.
#
# Más detalles por favor verifique el siguiente artículo:
# http://antirez.com/post/redis-persistence-demystified.html
#
# Si no está seguro, use "everysec".

# appendfsync siempre
appendfsync cadasec
# appendfsync no

# Cuando la política de AOF fsync se establece en siempre o en todos los segundos, y un fondo
# proceso de guardado (un guardado de fondo o reescritura de fondo de registro AOF) es
# Realizar mucha E/S contra el disco, en algunas configuraciones de Linux
# Redis puede bloquear demasiado tiempo en la llamada fsync(). Tenga en cuenta que no hay solución para
# esto actualmente, ya que incluso realizar fsync en un hilo diferente se bloqueará
# nuestra llamada síncrona write(2).
#
# Para mitigar este problema es posible utilizar la siguiente opción
# eso evitará que fsync() sea llamado en el proceso principal mientras que a
# BGSAVE o BGREWRITEAOF está en progreso.
#
# Esto significa que mientras otro niño está ahorrando, la durabilidad de Redis es
# lo mismo que "appendfsync none". En términos prácticos, esto significa que lo es
# posible perder hasta 30 segundos de log en el peor escenario (con el
# configuración predeterminada de Linux).
#
# Si tiene problemas de latencia, convierta esto en "sí". De lo contrario, déjalo como
# "no" que es la elección más segura desde el punto de vista de la durabilidad.

no-appendfsync-on-rewrite no

# Reescritura automática del archivo append only.
# Redis puede reescribir automáticamente el archivo de registro llamando implícitamente
# BGREWRITEAOF cuando el tamaño del registro AOF crece en el porcentaje especificado.
#
# Así es como funciona: Redis recuerda el tamaño del archivo AOF después del
# última reescritura (si no ha ocurrido ninguna reescritura desde el reinicio, el tamaño de
# se utiliza el AOF al inicio).
#
# Este tamaño base se compara con el tamaño actual. Si el tamaño actual es
# más grande que el porcentaje especificado, se activa la reescritura. También
# debe especificar un tamaño mínimo para que el archivo AOF se reescriba, esto
# es útil para evitar reescribir el archivo AOF incluso si el porcentaje aumenta
# se alcanza, pero todavía es bastante pequeño.
#
# Especifique un porcentaje de cero para deshabilitar el AOF automático
# característica de reescritura.

auto-aof-rewrite-porcentaje 100
auto-aof-rewrite-min-tamaño 64mb

# Se puede encontrar que un archivo AOF se trunca al final durante el Redis
# proceso de inicio, cuando los datos AOF se cargan de nuevo en la memoria.
# Esto puede suceder cuando el sistema donde se está ejecutando Redis
# se bloquea, especialmente cuando se monta un sistema de archivos ext4 sin el
# opción data=ordered (sin embargo, esto no puede suceder cuando Redis mismo
# se bloquea o aborta, pero el sistema operativo todavía funciona correctamente).
#
# Redis puede salir con un error cuando esto sucede, o cargar tanto
# datos como sea posible (el valor predeterminado ahora) e inicie si se encuentra el archivo AOF
# para ser truncado al final. La siguiente opción controla este comportamiento.
#
# Si aof-load-truncated se establece en sí, se carga un archivo AOF truncado y
# el servidor Redis comienza a emitir un registro para informar al usuario del evento.
# De lo contrario, si la opción se establece en no, el servidor aborta con un error
# y se niega a empezar. Cuando la opción se establece en no, el usuario requiere
# para reparar el archivo AOF utilizando la utilidad "redis-check-aof" antes de reiniciar
# el servidor.
#
# Tenga en cuenta que si se encuentra que el archivo AOF está dañado en el medio
# el servidor seguirá saliendo con un error. Esta opción solo se aplica cuando
# Redis intentará leer más datos del archivo AOF pero no suficientes bytes
# será encontrado.
sí de carga truncada

# Al reescribir el archivo AOF, Redis puede usar un preámbulo RDB en el
# Archivo #AOF para reescrituras y recuperaciones más rápidas. Cuando se gira esta opción
# en el archivo AOF reescrito se compone de dos estrofas diferentes:
#
#   [Archivo RDB][cola AOF]
#
# Al cargar Redis reconoce que el archivo AOF comienza con el "REDIS"
# cadena y carga el archivo RDB prefijado, y continúa cargando el AOF
# cola.
aof-use-rdb-preámbulo sí

################################ LUA SCRIPTING  ###############################

# Tiempo máximo de ejecución de un script Lua en milisegundos.
#
# Si se alcanza el tiempo máximo de ejecución, Redis registrará que se trata de un script
# todavía en ejecución después del tiempo máximo permitido y comenzará a
# responder a consultas con un error.
#
# Cuando un script de larga duración excede el tiempo máximo de ejecución, solo el
# Los comandos SCRIPT KILL y SHUTDOWN NOSAVE están disponibles. El primero puede ser
# solía detener un script que aún no llamaba comandos de escritura. El segundo
# es la única forma de apagar el servidor en el caso de que haya un comando de escritura
# ya emitido por el script pero el usuario no quiere esperar a lo natural
# terminación del script.
#
# Establezca en 0 o un valor negativo para una ejecución ilimitada sin advertencias.
lua-tiempo-límite 5000

################################ REDIS CLUSTER  ###############################

# Las instancias normales de Redis no pueden ser parte de un clúster de Redis; solo nodos que son
# comenzó como los nodos del clúster pueden. Para iniciar una instancia de Redis como un
# nodo de clúster habilite el soporte de clúster descomentando lo siguiente:
#
# habilitado para clúster sí

# Cada nodo de clúster tiene un archivo de configuración de clúster. Este archivo no lo es
# destinado a ser editado a mano. Es creado y actualizado por los nodos de Redis.
# Cada nodo de Redis Cluster requiere un archivo de configuración de clúster diferente.
# Asegúrese de que las instancias que se ejecutan en el mismo sistema no tengan
# nombres de archivo de configuración de clúster superpuestos.
#
# clúster-config-archivo nodos-6379.conf

# El tiempo de espera del nodo del clúster es la cantidad de milisegundos que un nodo debe ser inalcanzable
# para que se considere en estado de falla.
# La mayoría de los otros límites de tiempo internos son múltiples del tiempo de espera del nodo.
#
# cluster-node-timeout 15000

# Una réplica de un maestro fallido evitará iniciar una conmutación por error si sus datos
# parece demasiado viejo.
#
# No hay una manera simple para que una réplica realmente tenga una medida exacta de
# su "edad de datos", por lo que se realizan las siguientes dos comprobaciones:
#
# 1) Si hay varias réplicas capaces de conmutación por error, intercambian mensajes
#    con el fin de tratar de dar una ventaja a la réplica con el mejor
#    desplazamiento de replicación (más datos del maestro procesados).
#    Las réplicas intentarán obtener su rango por compensación y se aplicarán al inicio
#    de la conmutación por error un retraso proporcional a su rango.
#
# 2) Cada réplica calcula el tiempo de la última interacción con
#    su maestro. Este puede ser el último ping o comando recibido (si el maestro
#    todavía está en el estado "conectado"), o el tiempo que transcurrió desde el
#    desconexión con el maestro (si el enlace de replicación está actualmente inactivo).
#    Si la última interacción es demasiado antigua, la réplica no intentará la conmutación por error
#    en absoluto.
#
# El punto "2" puede ser sintonizado por el usuario. Específicamente, una réplica no funcionará
# la conmutación por error si, desde la última interacción con el maestro, el tiempo
# transcurrido es mayor que:
#
#   (node-timeout * replica-validez-factor) + repl-ping-replica-periodo
#
# Entonces, por ejemplo, si el tiempo de espera del nodo es de 30 segundos y el factor de validez de la réplica
# es 10, y suponiendo un período de repetición-ping-réplica predeterminado de 10 segundos, el
# la réplica no intentará la conmutación por error si no pudo hablar con el maestro
# por más de 310 segundos.
#
# Un factor de validez de réplica grande puede permitir que las réplicas con datos demasiado antiguos fallen
# un maestro, mientras que un valor demasiado pequeño puede evitar que el clúster pueda hacerlo
# elige una réplica en absoluto.
#
# Para una disponibilidad máxima, es posible establecer el factor de validez de réplica
# a un valor de 0, lo que significa que las réplicas siempre intentarán hacer una conmutación por error
# maestro independientemente de la última vez que interactuaron con el maestro.
# (Sin embargo, siempre intentarán aplicar un retraso proporcional a su
# rango offset).
#
# Cero es el único valor capaz de garantizar que cuando todas las particiones sanen
# el clúster siempre podrá continuar.
#
# cluster-replica-validez-factor 10

# Las réplicas de clúster pueden migrar a maestros huérfanos, que son maestros
# que quedan sin réplicas de trabajo. Esto mejora la capacidad del clúster
# para resistir a los fracasos ya que de lo contrario un maestro huérfano no puede ser fallado
# en caso de fallo si no tiene réplicas de trabajo.
#
# Las réplicas migran a maestros huérfanos solo si todavía hay al menos un
# dado el número de otras réplicas de trabajo para su antiguo maestro. Este número
# es la "barrera migratoria". Una barrera de migración de 1 significa que una réplica
# migrará solo si hay al menos 1 otra réplica de trabajo para su maestro
# y así sucesivamente. Por lo general, refleja la cantidad de réplicas que desea para cada
# maestro en tu clúster.
#
# El valor predeterminado es 1 (las réplicas migran solo si sus maestros permanecen con al menos
# una réplica). Para deshabilitar la migración, simplemente configúrela en un valor muy grande.
# Se puede establecer un valor de 0, pero es útil solo para depurar y peligroso
# en producción.
#
# clúster-migración-barrera 1

# De forma predeterminada, los nodos de Redis Cluster dejan de aceptar consultas si las detectan allí
# es al menos una ranura hash descubierta (ningún nodo disponible lo está sirviendo).
# De esta manera, si el clúster está parcialmente inactivo (por ejemplo, un rango de ranuras hash
# ya no están cubiertos) todo el clúster se vuelve, eventualmente, no disponible.
# Devuelve automáticamente disponible tan pronto como todas las ranuras se cubren de nuevo.
#
# Sin embargo, a veces desea el subconjunto del clúster que está funcionando,
# para seguir aceptando consultas para la parte del espacio clave que aún está
# cubierto. Para hacerlo, simplemente establezca la cobertura completa del requisito de clúster
# opción a no.
#
# cluster-require-full-coverage sí

# Esta opción, cuando se establece en sí, evita que las réplicas intenten pasar por error
# maestro durante los fracasos maestros. Sin embargo, el maestro todavía puede realizar un
# conmutación por error manual, si se ve obligado a hacerlo.
#
# Esto es útil en diferentes escenarios, especialmente en el caso de múltiples
# operaciones del centro de datos, donde queremos que un lado nunca se promocione si no
# en el caso de una falla total de DC.
#
# cluster-replica-no-failover no

# Para configurar su clúster, asegúrese de leer la documentación
# disponible en http://redis.io sitio web.

########################## CLUSTER DOCKER/NAT support  ########################

# En ciertas implementaciones, el descubrimiento de direcciones de nodos de Redis Cluster falla, porque
# Las direcciones # están NAT-ted o porque los puertos están reenviados (el caso típico es
# Docker y otros contenedores).
#
# Para hacer que Redis Cluster funcione en tales entornos, es una estática
# configuración donde cada nodo sabe que su dirección pública es necesaria. El
# Las siguientes dos opciones se utilizan para este alcance, y son:
#
# * cluster-announce-ip
# * clúster-announce-port
# * cluster-announce-bus-port
#
# Cada uno instruye al nodo sobre su dirección, puerto de cliente y mensaje de clúster
# puerto de autobuses. La información se publica entonces en el encabezado de los paquetes de bus
# para que otros nodos puedan mapear correctamente la dirección del nodo
# publicar la información.
#
# Si no se utilizan las opciones anteriores, la detección automática normal de Redis Cluster
# se utilizará en su lugar.
#
# Tenga en cuenta que cuando se reasigna, el puerto de bus puede no estar en el desplazamiento fijo de
# puerto de clientes + 10000, para que pueda especificar cualquier puerto y puerto de autobús dependiendo
# sobre cómo se reasignan. Si el puerto de bus no está configurado, un desplazamiento fijo de
# 10000 se utilizará como de costumbre.
#
# Ejemplo:
#
# clúster-announce-ip 10.1.1.5
# clúster-announce-puerto 6379
# clúster-announce-bus-port 6380

################################## SLOW LOG ###################################

# El Redis Slow Log es un sistema para registrar consultas que excedieron un determinado
# tiempo de ejecución. El tiempo de ejecución no incluye las operaciones de E/S
# como hablar con el cliente, enviar la respuesta, etc,
# pero solo el tiempo necesario para ejecutar realmente el comando (este es el único
# etapa de ejecución de comandos donde el hilo está bloqueado y no puede servir
# otras solicitudes mientras tanto).
#
# Puede configurar el registro lento con dos parámetros: uno le dice a Redis
# cuál es el tiempo de ejecución, en microsegundos, a exceder en orden para el
# comando para obtener logged, y el otro parámetro es la longitud de la
# registro lento. Cuando se registra un nuevo comando, el más antiguo se elimina del
# cola de comandos registrados.

# El siguiente tiempo se expresa en microsegundos, por lo que 1000000 es equivalente
# a un segundo. Tenga en cuenta que un número negativo deshabilita el registro lento, mientras que
# un valor de cero fuerza el registro de cada comando.
slowlog-log-más lento que 10000

# No hay límite para esta longitud. Solo ten en cuenta que consumirá memoria.
# Puede recuperar la memoria utilizada por el registro lento con SLOWLOG RESET.
slowlog-max-len 128

################################ MONITOR DE LATENCIA ##############################

# El subsistema de monitoreo de latencia de Redis muestrea diferentes operaciones
# en tiempo de ejecución para recopilar datos relacionados con posibles fuentes de
# latencia de una instancia de Redis.
#
# A través del comando LATENCY esta información está disponible para el usuario que puede
# imprime gráficos y obtén informes.
#
# El sistema solo registra las operaciones que se realizaron en un tiempo igual o
# mayor que la cantidad de milisegundos especificados a través de la
# Directiva de configuración de umbral de monitor de latencia. Cuando se establece su valor
# a cero, el monitor de latencia está apagado.
#
# Por defecto, el monitoreo de latencia está deshabilitado ya que en su mayoría no es necesario
# si no tiene problemas de latencia, y la recopilación de datos tiene un rendimiento
# impacto, que si bien es muy pequeño, se puede medir bajo una gran carga. Latencia
# El monitoreo # se puede habilitar fácilmente en tiempo de ejecución usando el comando
# "CONFIG SET latencia-monitor-umbral <milliseconds>" si es necesario.
umbral de monitoreo de latencia 0

############################# NOTIFICACIÓN DE EVENTO ##############################

# Redis puede notificar a los clientes de Pub/Sub sobre los eventos que ocurren en el espacio clave.
# Esta característica está documentada en http://redis.io/topics/notifications
#
# Por ejemplo, si la notificación de eventos del espacio de claves está habilitada y un cliente
# realiza una operación DEL en la clave "foo" almacenada en la base de datos 0, dos
# Los mensajes se publicarán a través de Pub/Sub:
#
# PUBLICAR __keyspace@0__:foo del
# PUBLICAR __keyevent@0__:del foo
#
# Es posible seleccionar los eventos que Redis notificará entre un conjunto
# de clases. Cada clase se identifica por un solo carácter:
#
#  K Keyspace events, publicado con el prefijo __keyspace@<db>__.
#  E Keyevent events, publicado con el prefijo __keyevent@<db>__.
#  g Comandos genéricos (no específicos) como DEL, EXPIRE, RENAME, ...
#  $ Comandos de cuerda
#  l Comandos de lista
#  s Establecer comandos
#  h Comandos hash
#  z Ordenó comandos de conjunto
#  x Eventos caducados (eventos generados cada vez que caduca una clave)
#  e Eventos desalojados (eventos generados cuando una clave es desalojada para maxmemory)
#  Un alias para g$lshzxe, de modo que la cadena "AKE" signifique todos los eventos.
#
#  El "notify-keyspace-events" toma como argumento una cadena que está compuesta
#  de cero o múltiples caracteres. La cadena vacía significa que las notificaciones
#  están deshabilitados.
#
#  Ejemplo: para habilitar eventos de lista y genéricos, desde el punto de vista de la
#           nombre del evento, uso:
#
#  notify-keyspace-events Elg
#
#  Ejemplo 2: para obtener el flujo de las claves vencidas que se suscriben al canal
#             nombre __keyevent@0__:uso vencido:
#
#  notify-keyspace-events Ex
#
#  De forma predeterminada, todas las notificaciones están deshabilitadas porque la mayoría de los usuarios no necesitan
#  esta característica y la característica tiene algunos gastos generales. Tenga en cuenta que si no lo hace
#  especifique al menos uno de K o E, no se entregarán eventos.
notify-keyspace-eventos ""

############################### AVANZADO CONFIG ###############################

# Los hashes se codifican utilizando una estructura de datos eficiente de memoria cuando tienen un
# pequeño número de entradas, y la entrada más grande no excede un dado
# umbral. Estos umbrales se pueden configurar utilizando las siguientes directivas.
hash-max-ziplist-entradas 512
valor hash-max-ziplist 64

# Las listas también están codificadas de una manera especial para ahorrar mucho espacio.
# Se puede especificar el número de entradas permitidas por nodo de lista interna
# como un tamaño máximo fijo o un número máximo de elementos.
# Para un tamaño máximo fijo, use - 5 a - 1, que significa:
# -5: tamaño máximo: 64 Kb <-- no recomendado para cargas de trabajo normales
# -4: tamaño máximo: 32 Kb <-- no recomendado
# -3: tamaño máximo: 16 Kb <-- probablemente no recomendado
# -2: tamaño máximo: 8 Kb <-- bueno
# -1: tamaño máximo: 4 Kb <-- bueno
# Los números positivos significan almacenar hasta _exactamente_ ese número de elementos
# por nodo de lista.
# La opción de mayor rendimiento suele ser - 2 (tamaño de 8 Kb) o - 1 (tamaño de 4 Kb),
# pero si su caso de uso es único, ajuste la configuración según sea necesario.
lista-max-ziplist-tamaño -2

# Las listas también pueden comprimirse.
# Profundidad de compresión es el número de nodos ziplist de lista rápida de * cada lado* de
# la lista a *excluir* desde la compresión.  La cabeza y la cola de la lista
# siempre están sin comprimir para operaciones rápidas push/pop.  La configuración es:
# 0: deshabilite toda la compresión de la lista
# 1: profundidad 1 significa "no comience a comprimir hasta después de 1 nodo en la lista,
#    yendo desde la cabeza o la cola"
#    Entonces: [head]->node->node->...->node->[tail]
#    [cabeza], [cola] siempre estará sin comprimir; los nodos internos se comprimirán.
# 2: [head]->[next]->node->node->...->node->[prev]->[tail]
#    2 aquí significa: no comprimir cabeza o cabeza->next o cola->prev o cola,
#    pero comprime todos los nodos entre ellos.
# 3: [head]->[next]->[next]->node->node->...->node->[prev]->[prev]->[tail]
# etc.
lista-compresión-profundidad 0

# Los conjuntos tienen una codificación especial en un solo caso: cuando se compone un conjunto
# de solo cadenas que resultan ser enteros en el radix 10 en el rango
# de enteros firmados de 64 bits.
# La siguiente configuración establece el límite en el tamaño de la
# establecido para usar esta codificación especial de ahorro de memoria.
set-max-intset-entradas 512

# De manera similar a los hashes y listas, los conjuntos ordenados también están especialmente codificados
# orden para ahorrar mucho espacio. Esta codificación solo se usa cuando la longitud y
# los elementos de un conjunto ordenado están por debajo de los siguientes límites:
zset-max-ziplist-entradas 128
valor zset-max-ziplist 64

# HyperLogLog límite de bytes de representación dispersa. El límite incluye el
# 16 bytes de encabezado. Cuando un HyperLogLog que usa la representación dispersa se cruza
# este límite, se convierte en la representación densa.
#
# Un valor superior a 16000 es totalmente inútil, ya que en ese punto el
# la representación densa es más eficiente en memoria.
#
# El valor sugerido es ~ 3000 para tener los beneficios de
# la codificación eficiente del espacio sin ralentizar demasiado PFADD,
# que es O(N) con la codificación dispersa. El valor puede ser elevado a
# ~ 10000 cuando la CPU no es una preocupación, pero el espacio lo es, y el conjunto de datos lo es
# compuesto por muchos HyperLogLogs con cardinalidad en el rango 0 - 15000.
hll-sparse-max-bytes 3000

# Streams macro node tamaño máximo /elementos. La estructura de datos de flujo es un radix
# árbol de nodos grandes que codifican varios elementos dentro. Usando esta configuración
# es posible configurar qué tan grande puede ser un solo nodo en bytes, y el
# número máximo de elementos que puede contener antes de cambiar a un nuevo nodo cuando
# añadir nuevas entradas de flujo. Si alguna de las siguientes configuraciones está establecida en
# cero, el límite se ignora, por lo que, por ejemplo, es posible establecer solo un
# max entires limite estableciendo max-bytes en 0 y max-entries a lo deseado
# valor.
flujo-nodo-max-bytes 4096
entradas de nodo de flujo-max 100

# La repetición activa utiliza 1 milisegundo cada 100 milisegundos de tiempo de CPU en
# orden para ayudar a rehacer la tabla hash principal de Redis (la que mapea el nivel superior
# claves de valores). Implementación de la tabla hash que utiliza Redis (ver dict.c)
# realiza una repetición perezosa: cuanta más operación se encuentre en una tabla hash
# que está rehashing, más "pasos" rehashing se realizan, así que si el
# el servidor está inactivo, la repetición nunca se completa y se usa más memoria
# por la tabla hash.
#
# El valor predeterminado es usar este milisegundo 10 veces por segundo para
# rehash activamente los diccionarios principales, liberando memoria cuando sea posible.
#
# Si no está seguro:
# use "activerehashing no" si tiene requisitos de latencia difíciles y lo es
# no es algo bueno en su entorno que Redis pueda responder de vez en cuando
# a consultas con 2 milisegundos de retraso.
#
# use "activerehashing sí" si no tiene requisitos tan difíciles pero
# quiere liberar la memoria lo antes posible.
activerehashing sí

# Los límites del búfer de salida del cliente se pueden usar para forzar la desconexión de los clientes
# que no están leyendo datos del servidor lo suficientemente rápido por alguna razón (a
# la razón común es que un cliente Pub/Sub no puede consumir mensajes tan rápido como el
# el editor puede producirlos).
#
# El límite se puede establecer de manera diferente para las tres clases diferentes de clientes:
#
# normal -> clientes normales incluyendo clientes MONITOR
# réplica -> réplica clientes
# pubsub -> clientes suscritos a al menos un canal o patrón pubsub
#
# La sintaxis de cada directiva cliente-salida-búfer-límite es la siguiente:
#
# client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>
#
# Un cliente se desconecta inmediatamente una vez que se alcanza el límite duro, o si
# se alcanza el límite blando y se mantiene alcanzado para el número especificado de
# segundos (continuamente).
# Entonces, por ejemplo, si el límite duro es de 32 megabytes y el límite blando es
# 16 megabytes /10 segundos, el cliente se desconectará inmediatamente
# si el tamaño de los buffers de salida alcanza los 32 megabytes, pero también obtendrá
# desconectado si el cliente alcanza los 16 megabytes y supera continuamente
# el límite durante 10 segundos.
#
# Por defecto, los clientes normales no están limitados porque no reciben datos
# sin preguntar (de una manera push), pero justo después de una solicitud, así que solo
# los clientes asíncronos pueden crear un escenario donde los datos se solicitan más rápido
# de lo que puede leer.
#
# En cambio, hay un límite predeterminado para los clientes de pubsub y réplicas, ya que
# los suscriptores y las réplicas reciben datos de una manera push.
#
# Tanto el límite duro como el límite blando se pueden desactivar configurándolos en cero.
cliente-salida-buffer-límite normal 0 0 0
réplica de límite de búfer de salida de cliente 256mb 64mb 60
cliente-salida-buffer-limit pubsub 32mb 8mb 60

# Los búferes de consulta del cliente acumulan nuevos comandos. Están limitados a un fijo
# cantidad por defecto con el fin de evitar que un protocolo de desincronización (para
# instancia debido a un error en el cliente) conducirá al uso de memoria no vinculada en
# el búfer de consulta. Sin embargo, puede configurarlo aquí si tiene muy especial
# necesidades, tales como enormes solicitudes multi/ejec o similares.
#
# cliente-consulta-buffer-límite 1gb

# En el protocolo Redis, solicitudes masivas, es decir, elementos que representan elementos individuales
# cadenas, normalmente están limitadas a 512 mb. Sin embargo, puede cambiar este límite
# aquí.
#
# proto-max-bulk-len 512mb

# Redis llama a una función interna para realizar muchas tareas en segundo plano, como
# cerrar conexiones de clientes en tiempo de espera, purgando claves vencidas que son
# nunca solicitado, y así sucesivamente.
#
# No todas las tareas se realizan con la misma frecuencia, pero Redis comprueba para
# tareas a realizar de acuerdo con el valor "hz" especificado.
#
# Por defecto "hz" se establece en 10. Aumentar el valor usará más CPU cuando
# Redis está inactivo, pero al mismo tiempo hará que Redis sea más receptivo cuando
# hay muchas claves que caducan al mismo tiempo, y los tiempos de espera pueden ser
# manejado con más precisión.
#
# El rango está entre 1 y 500, sin embargo, un valor superior a 100 generalmente no lo está
# una buena idea. La mayoría de los usuarios deben usar el valor predeterminado de 10 y aumentar esto a
# 100 solo en entornos donde se requiere una latencia muy baja.
hz 10

# Normalmente es útil tener un valor HZ que sea proporcional al
# número de clientes conectados. Esto es útil para, por ejemplo,
# evite que se procesen demasiados clientes para cada invocación de tarea en segundo plano
# para evitar picos de latencia.
#
# Dado que el valor HZ predeterminado por defecto se establece de forma conservadora en 10, Redis
# ofrece, y habilita de forma predeterminada, la capacidad de usar un valor HZ adaptativo
# que aumentará temporalmente cuando haya muchos clientes conectados.
#
# Cuando el HZ dinámico está habilitado, el HZ configurado real se utilizará como
# como línea de base, pero los múltiplos del valor de HZ configurado serán en realidad
# usado según sea necesario una vez más clientes están conectados. De esta manera un ocioso
# instancia utilizará muy poco tiempo de CPU mientras que una instancia ocupada será
# más receptivo.
dinámico-hz sí

# Cuando un niño reescribe el archivo AOF, si la siguiente opción está habilitada
# el archivo será fsync-ed cada 32 MB de datos generados. Esto es útil
# para comprometer el archivo al disco de forma más incremental y evitar
# grandes picos de latencia.
aof-rewrite-incremental-fsync sí

# Cuando redis guarda el archivo RDB, si la siguiente opción está habilitada
# el archivo será fsync-ed cada 32 MB de datos generados. Esto es útil
# para comprometer el archivo al disco de forma más incremental y evitar
# grandes picos de latencia.
rdb-save-incremental-fsync sí

# Redis LFU desalojo (ver configuración de maxmemory) puede ser sintonizado. Sin embargo, es bueno
# idea para comenzar con la configuración predeterminada y solo cambiarlos después de investigar
# cómo mejorar el rendimiento y cómo las teclas LFU cambian con el tiempo, que
# es posible inspeccionar a través del comando OBJECT FREQ.
#
# Hay dos parámetros sintonizables en la implementación de Redis LFU: el
# factor de logaritmo de contador y el tiempo de decaimiento del contador. Es importante
# entienda lo que significan los dos parámetros antes de cambiarlos.
#
# El contador LFU es solo 8 bits por clave, su valor máximo es 255, por lo que Redis
# utiliza un incremento probabilístico con comportamiento logarítmico. Dado el valor
# del contador antiguo, cuando se accede a una clave, el contador se incrementa en
# de esta manera:
#
# 1. Se extrae un número aleatorio R entre 0 y 1.
# 2. Una probabilidad P se calcula como 1/(old_value*lfu_log_factor+1).
# 3. El contador se incrementa solo si R < P.
#
# El factor lfu-log predeterminado es 10. Esta es una tabla de cómo la frecuencia
# contador de cambios con un número diferente de accesos con diferentes
# factores logarítmicos:
#
# + --------- + ------------- + ------------- + ------------- + ------------- + --------- +
# | factor | 100 hits | 1000 hits | 100K hits | 1M hits | 10M hits |
# + --------- + ------------- + ------------- + ------------- + ------------- + --------- +
# | 0 | 104 | 255 | 255 | 255 | 255 |
# + --------- + ------------- + ------------- + ------------- + ------------- + --------- +
# | 1 | 18 | 49 | 255 | 255 | 255 |
# + --------- + ------------- + ------------- + ------------- + ------------- + --------- +
# | 10 | 10 | 18 | 142 | 255 | 255 |
# + --------- + ------------- + ------------- + ------------- + ------------- + --------- +
# | 100 | 8 | 11 | 49 | 143 | 255 |
# + --------- + ------------- + ------------- + ------------- + ------------- + --------- +
#
# NOTA: La tabla anterior se obtuvo ejecutando los siguientes comandos:
#
#   redis-benchmark -n 1000000 incr foo
#   redis-cli objeto freq foo
#
# NOTA 2: El valor inicial del contador es 5 para dar una oportunidad a los nuevos objetos
# para acumular golpes.
#
# El tiempo de descomposición del contador es el tiempo, en minutos, que debe transcurrir en orden
# para que el contador de claves se divida por dos ( o se decremente si tiene un valor
# menos < = 10 ).
#
# El valor predeterminado para el tiempo de desintegración de lfu es 1. Un valor especial de 0 significa
# decae el contador cada vez que se escanea.
#
# factor lfu-log 10
# lfu-decay-tiempo 1

########################### DEFRAGMENTACIÓN ACTIVA #######################
#
# ADVERTENCIA ESTA CARACTERÍSTICA ES EXPERIMENTAL. Sin embargo, fue probado por estrés
# incluso en producción y probado manualmente por múltiples ingenieros para algunos
# tiempo.
#
# Qué es la desfragmentación activa?
# --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#
# La desfragmentación activa (en línea) permite que un servidor Redis compacte el
# espacios dejados entre pequeñas asignaciones y asignaciones de datos en la memoria,
# permitiendo así recuperar la memoria posterior.
#
# La fragmentación es un proceso natural que ocurre con cada asignador (pero
# menos con Jemalloc, afortunadamente) y ciertas cargas de trabajo. Normalmente un servidor
# se necesita reiniciar para reducir la fragmentación, o al menos para enjuagar
# lejos todos los datos y crearlo de nuevo. Sin embargo, gracias a esta característica
# implementado por Oran Agra para Redis 4.0 este proceso puede ocurrir en tiempo de ejecución
# de una manera "caliente", mientras el servidor se está ejecutando.
#
# Básicamente cuando la fragmentación está sobre un cierto nivel (ver el
# opciones de configuración a continuación) Redis comenzará a crear nuevas copias de la
# valores en regiones de memoria contiguas explotando ciertos Jemalloc específicos
# características (para entender si una asignación está causando fragmentación
# y para asignarlo en un lugar mejor), y al mismo tiempo, lanzará el
# copias antiguas de los datos. Este proceso, repetido incrementalmente para todas las claves
# hará que la fragmentación vuelva a caer a los valores normales.
#
# Cosas importantes a entender:
#
# 1. Esta función está deshabilitada de forma predeterminada y solo funciona si compiló Redis
#    para usar la copia de Jemalloc enviamos con el código fuente de Redis.
#    Este es el valor predeterminado con las compilaciones de Linux.
#
# 2. Nunca necesita habilitar esta función si no tiene fragmentación
#    problemas.
#
# 3. Una vez que experimente fragmentación, puede habilitar esta función cuando
#    necesario con el comando "CONFIG SET activedefrag yes".
#
# Los parámetros de configuración pueden ajustar el comportamiento de la
# proceso de desfragmentación. Si no está seguro de lo que significan es
# una buena idea para dejar los valores predeterminados intactos.

# Desfragmentación activa habilitada
# activedefrag sí

# Cantidad mínima de residuos de fragmentación para iniciar la desfragmentación activa
# activo-desfrag-ignore-bytes 100mb

# Porcentaje mínimo de fragmentación para iniciar la desfragmentación activa
# activo-desfrag-umbral-inferior 10

# Porcentaje máximo de fragmentación en el que utilizamos el máximo esfuerzo
# activo-desfrag-umbral-superior 100

# Esfuerzo mínimo para desfragmentar en porcentaje de CPU
# activo-desfrag-ciclo-min 5

# Esfuerzo máximo para desfragmentar en porcentaje de CPU
# activo-desfrag-ciclo-max 75

# Número máximo de campos set/hash/zset/list que se procesarán desde
# el escaneo principal del diccionario
# active-defrag-max-scan-fields 1000

# En algunos casos, redis emitirá advertencias e incluso se negará a comenzar si lo detecta
# que el sistema está en mal estado, es posible suprimir estas advertencias
# configurando la siguiente configuración que toma una lista de advertencias delimitada por espacio
# para suprimir
#
# ignorar-advertencias ARM64-COW-BUG
